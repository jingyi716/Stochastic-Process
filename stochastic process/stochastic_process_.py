# -*- coding: utf-8 -*-
"""Stochastic Process .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10HQDgSV7n7rW0kIpIwlyhNlMoe_V-Trk
"""

## Suppose the time between bus arrivals is exponentially distributed with mean of 15 minutes and the first one arrived at 8am. Use Python to simulate the arrival process between 8am to 8am (of the following day). Count the number of arrivals in the first hour (excluding the first arrival), the second hour, . . ., and the 24th hour. Plot the histogram of these 24 number
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats
x=0
y=0
k=[]
n=1
i=0
while n <= 24:
  time_between_arrivals= np.random.exponential(scale=1/4)
  y=y+time_between_arrivals
  x=x+1
  while y>n:
    x=x-1
    if x<0:
      x=0
    k.append(x)
    x=0
    n=n+1
plt.hist(k)
plt.legend(loc="upper right")
plt.show()

#You have two opponents with whom you alternate play. Whenever you play A, you win
#with probability pA; whenever you play B, you win with probability pB , where pB < pA. Suppose
#pA = 0.7 and pB = 0.4. If your objective is to minimize the expected number of games you need to play to win two in
#a row, should you start with A or with B? Simulate it with Python 1000 times and use sample
#mean to compute the expected number of games you need to play when you start with A and B,
#respectively
import numpy as np
import random as rnd
N=1
n=0
A=0
B=0
k=[]
while N<=1000:
  rnd_num= rnd.random()
  if rnd_num<=0.7 and A<1:
    A=A+1
    n=n+1
  else:
    n=n+1
    B=0
  if A==1 and B==1:
    k.append(n)
    A=0
    B=0
    n=0
    N=N+1
  rnd_num= rnd.random()
  if rnd_num<=0.4 and B<1:
    B=B+1
    n=n+1
  else:
    n=n+1
    A=0
  if A==1 and B==1:
    k.append(n)
    A=0
    B=0
    n=0
    N=N+1

E_A=sum(k)/1000
E_A

import numpy as np
import random as rnd
N=1
n=0
A=0
B=0
k=[]
while N<=1000:
  rnd_num= rnd.random()
  if rnd_num<=0.4 and A<1:
    A=A+1
    n=n+1
  else:
    n=n+1
    B=0
  if A==1 and B==1:
    k.append(n)
    A=0
    B=0
    n=0
    N=N+1
  rnd_num= rnd.random()
  if rnd_num<=0.7 and B<1:
    B=B+1
    n=n+1
  else:
    n=n+1
    A=0
  if A==1 and B==1:
    k.append(n)
    A=0
    B=0
    n=0
    N=N+1

E_B=sum(k)/1000
E_B

#We throw a fair dice repeatedly and independently. Let X11 be the first time the pattern
#11 (two consecutive 1’s) appears and X12 the first time the pattern 12 (1 followed by 2) ap-
#pears. Simulate it with Python 1000 times then use sample mean and sample variance to estimate
#E[X11], E[X12], Var(X11), Var(X12)
import numpy as np
import random as rnd
N=1
n=0
A=0
B=0
k=[]
while N<=1000:
  rnd_num= rnd.randint(1,6)
  if rnd_num==1 and A<1:
    A=A+1
    n=n+1
  else:
    n=n+1
    B=0
  if A==1 and B==1:
    k.append(n)
    A=0
    B=0
    n=0
    N=N+1
  rnd_num= rnd.randint(1,6)
  if rnd_num==1 and B<1:
    B=B+1
    n=n+1
  else:
    n=n+1
    A=0
  if A==1 and B==1:
    k.append(n)
    A=0
    B=0
    n=0
    N=N+1

X_11=sum(k)/1000
print('the expectation value of X11 is',X_11)
Var_11=np.var(k)
print('the variance of X11 is',Var_11)

import numpy as np
import random as rnd
N=1
n=0
A=0
B=0
k=[]
while N<=1000:

  rnd_num= rnd.randint(1,6)
  if rnd_num==1:
    n=n+1
    if B==0:
      B=B+1
    if A==1:
      A=0
    if B==1:
      B=1
  elif rnd_num==2 and A<1:
    A=A+1
    n=n+1
  else:
    n=n+1
    A=0
    B=0

  if A==1 and B==1:
    k.append(n)
    A=0
    B=0
    n=0
    N=N+1

  rnd_num= rnd.randint(1,6)
  if rnd_num==2 and A<1:
    A=A+1
    n=n+1
  elif rnd_num==1:
    n=n+1
    if B==0:
      B=B+1
    if A==1:
      A=0
    if B==1:
      B=1
  else:
    n=n+1
    B=0
    A=0

  if A==1 and B==1:
    k.append(n)
    A=0
    B=0
    n=0
    N=N+1

X_12=sum(k)/1000
print('the expectation value of X12 is',X_12)
Var_12=np.var(k)
print('the variance of X12 is',Var_12)

##We aim to analyze a non-homogeneous Poisson process {N (t), t ≥ 0}, in which the time-
#dependent arrival rate λ(t) = sin(t) + 1 is a function of time t. The following is a standard
#procedure to simulate a non-homogeneous Poisson process:
#1. Denote  ̄λ = maxt λ(t). Initialize at t = 0.
#2. Simulate the arrival times of a homogeneous Poisson process with rate  ̄λ. Let S1, S2, . . . , Sn, . . .
#be the arrival times.
#3. For n = 1, 2, . . ., generate a uniform random variable U (0, 1) and denote it by Zn.
#4. If Un ≤ λ(Sn)/ ̄λ, then accept it as an arrival time of the non-homogeneous Poisson process
#at time Sn; and otherwise, reject it.
#Then, all the accepted arrival times constitute the non-homogeneous Poisson process with arrival
#rate function λ(t), t ≥ 0.
#Following the procedure above to simulate the non-homogeneous Poisson process from 0 to
#time 4π. Repeat it 1000 times, and create a histogram for N (4π) (number of arrivals in [0, 4π]) to
#approximate its distribution.
#Draw the pmf of a Poisson distribution with mean 4π on the same figure, and compare with
#the previous histogram.
import math
import numpy as np
import random
import matplotlib.pyplot as plt
from scipy.stats import poisson
rate_f = lambda t: max(0, math.sin(t)+1)

lambda_max = 2
k=[]
n=0
N=1
t = 0.0
while N<=1000:
  while True:
    t += random.expovariate(lambda_max)
    if t > 4*math.pi:
      break
    if random.random() <= rate_f(t) / lambda_max:
      n=n+1
  k.append(n)
  n=0
  t=0
  N=N+1
#plot histogram for N(4pi)
plt.hist(k,density=True, color='b')
x = np.arange(0, 30, 1)

# poisson distribution data for y-axis
y = poisson.pmf(x, mu=4*math.pi)
plt.plot(x, y,color='r')
plt.legend(loc="upper right")
plt.show()

